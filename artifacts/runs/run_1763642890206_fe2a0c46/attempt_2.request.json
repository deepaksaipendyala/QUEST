{
  "repo": "django/django",
  "version": "4.0",
  "code_file": "django/db/models/query_utils.py",
  "test_src": "import unittest\nfrom django.core.exceptions import FieldError\nfrom django.db.models.query_utils import Q, select_related_descend, FilteredRelation, check_rel_lookup_compatibility\n\nclass QueryUtilsTests(unittest.TestCase):\n\n    def test_q_combination_and(self):\n        q1 = Q(name='test')\n        q2 = Q(age=30)\n        combined = q1 & q2\n        self.assertTrue(isinstance(combined, Q))\n        self.assertEqual(combined.connector, Q.AND)\n        self.assertEqual(combined.children, [('test',), (30,)])\n        self.assertNotEqual(combined, q1)\n        self.assertNotEqual(combined, q2)\n\n    def test_q_combination_or(self):\n        q1 = Q(name='test')\n        q2 = Q(age=30)\n        combined = q1 | q2\n        self.assertTrue(isinstance(combined, Q))\n        self.assertEqual(combined.connector, Q.OR)\n        self.assertEqual(combined.children, [('test',), (30,)])\n        self.assertNotEqual(combined, q1)\n        self.assertNotEqual(combined, q2)\n\n    def test_q_negation(self):\n        q = Q(name='test')\n        negated = ~q\n        self.assertTrue(isinstance(negated, Q))\n        self.assertTrue(negated.negated)\n        self.assertEqual(negated.children, [('test',)])\n        self.assertNotEqual(negated, q)\n\n    def test_deconstruct_q(self):\n        q = Q(name='test', age=30)\n        path, args, kwargs = q.deconstruct()\n        self.assertIn('django.db.models.query_utils.Q', path)\n        self.assertEqual(args, ('test', 30))\n        self.assertEqual(kwargs, {})\n        self.assertNotEqual(q, Q(name='different'))\n\n    def test_select_related_descend(self):\n        field = unittest.mock.Mock()\n        field.remote_field = unittest.mock.Mock()\n        field.remote_field.parent_link = False\n        field.name = 'related_field'\n        field.null = False\n\n        self.assertTrue(select_related_descend(field, False, {'related_field': True}, set(), False))\n        self.assertFalse(select_related_descend(field, True, {'other_field': True}, set(), False))\n        self.assertFalse(select_related_descend(field, False, {'related_field': False}, set(), False))\n        self.assertFalse(select_related_descend(field, False, {'related_field': True}, set(), True))\n\n    def test_filtered_relation_init(self):\n        with self.assertRaises(ValueError):\n            FilteredRelation('', condition=Q())\n\n    def test_filtered_relation_condition(self):\n        fr = FilteredRelation('relation_name', condition=Q(name='test'))\n        self.assertEqual(fr.relation_name, 'relation_name')\n        self.assertEqual(fr.condition, Q(name='test'))\n        self.assertIsInstance(fr.condition, Q)\n        self.assertNotEqual(fr.condition, Q(name='different'))\n\n    def test_check_rel_lookup_compatibility(self):\n        model = unittest.mock.Mock()\n        target_opts = unittest.mock.Mock()\n        field = unittest.mock.Mock()\n        field.primary_key = False\n\n        model._meta.concrete_model = target_opts.concrete_model = 'TestModel'\n        self.assertTrue(check_rel_lookup_compatibility(model, target_opts, field))\n\n        field.primary_key = True\n        self.assertTrue(check_rel_lookup_compatibility(model, target_opts, field))\n\n        field.primary_key = False\n        field.related_model = 'AnotherModel'\n        self.assertFalse(check_rel_lookup_compatibility(model, target_opts, field))\n\n        field.related_model = None\n        self.assertFalse(check_rel_lookup_compatibility(model, target_opts, field))\n\n    def test_filtered_relation_eq(self):\n        fr1 = FilteredRelation('relation_name', condition=Q(name='test'))\n        fr2 = FilteredRelation('relation_name', condition=Q(name='test'))\n        fr3 = FilteredRelation('relation_name', condition=Q(name='different'))\n        self.assertEqual(fr1, fr2)\n        self.assertNotEqual(fr1, fr3)\n        self.assertNotEqual(fr1, None)\n\n    def test_filtered_relation_clone(self):\n        fr = FilteredRelation('relation_name', condition=Q(name='test'))\n        clone = fr.clone()\n        self.assertEqual(fr, clone)\n        self.assertIsNot(fr, clone)\n        self.assertEqual(fr.condition, clone.condition)\n        self.assertNotEqual(fr.relation_name, 'different_name')\n\n    def test_filtered_relation_repr(self):\n        fr = FilteredRelation('relation_name', condition=Q(name='test'))\n        self.assertIn('FilteredRelation', repr(fr))\n        self.assertIn('relation_name', repr(fr))\n        self.assertIn('Q(name=\\'test\\')', repr(fr))\n        self.assertNotIn('Q(name=\\'different\\')', repr(fr))\n\n    def test_q_combination_with_empty(self):\n        q1 = Q(name='test')\n        combined = q1 & Q()\n        self.assertEqual(combined, q1)\n        combined = q1 | Q()\n        self.assertEqual(combined, q1)\n        self.assertNotEqual(combined, Q(age=30))\n\n    def test_q_negation_with_empty(self):\n        negated = ~Q()\n        self.assertTrue(negated.negated)\n        self.assertEqual(negated.children, [])\n        self.assertNotEqual(negated, Q(name='test'))\n\n    def test_filtered_relation_condition_empty(self):\n        fr = FilteredRelation('relation_name', condition=Q())\n        self.assertEqual(fr.condition, Q())\n        self.assertNotEqual(fr.condition, Q(name='test'))\n\n    def test_check_rel_lookup_compatibility_with_none(self):\n        model = unittest.mock.Mock()\n        target_opts = unittest.mock.Mock()\n        field = unittest.mock.Mock()\n        field.primary_key = False\n        field.related_model = None\n\n        model._meta.concrete_model = target_opts.concrete_model = 'TestModel'\n        self.assertFalse(check_rel_lookup_compatibility(model, target_opts, field))\n\n        field.primary_key = True\n        self.assertTrue(check_rel_lookup_compatibility(model, target_opts, field))"
}
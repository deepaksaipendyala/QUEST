{
  "repo": "django/django",
  "version": "4.0",
  "code_file": "django/db/models/query_utils.py",
  "test_src": "import unittest\nfrom unittest.mock import Mock, patch\nfrom django.core.exceptions import FieldError\nfrom django.db.models.query_utils import Q, DeferredAttribute, select_related_descend, refs_expression, check_rel_lookup_compatibility, FilteredRelation\n\nclass QueryUtilsTests(unittest.TestCase):\n\n    def test_q_combination(self):\n        q1 = Q(name='John')\n        q2 = Q(age=30)\n        combined = q1 & q2\n        self.assertIsInstance(combined, Q)\n        self.assertEqual(combined.connector, Q.AND)\n\n        combined_or = q1 | q2\n        self.assertIsInstance(combined_or, Q)\n        self.assertEqual(combined_or.connector, Q.OR)\n\n        # Test empty Q objects\n        empty_q = Q()\n        combined_empty = empty_q & q1\n        self.assertEqual(combined_empty, q1)\n\n        combined_empty_or = empty_q | q1\n        self.assertEqual(combined_empty_or, q1)\n\n        # Additional assertions for negation\n        negated_combined = ~combined\n        self.assertIsInstance(negated_combined, Q)\n        self.assertTrue(negated_combined.negated)\n\n    def test_q_negation(self):\n        q = Q(name='John')\n        negated_q = ~q\n        self.assertIsInstance(negated_q, Q)\n        self.assertTrue(negated_q.negated)\n\n        # Test double negation\n        double_negated_q = ~~q\n        self.assertEqual(double_negated_q, q)\n\n        # Additional test for negation of combined Q\n        q_combined = q & Q(age=30)\n        negated_combined = ~q_combined\n        self.assertIsInstance(negated_combined, Q)\n\n    def test_deferred_attribute(self):\n        mock_field = Mock()\n        mock_field.attname = 'mock_field'\n        instance = Mock()\n        instance.__dict__ = {}\n        deferred_attr = DeferredAttribute(mock_field)\n\n        with patch.object(instance, 'refresh_from_db', return_value=None) as mock_refresh:\n            value = deferred_attr.__get__(instance)\n            self.assertIsNone(value)\n            mock_refresh.assert_called_once_with(fields=['mock_field'])\n\n        # Test setting the value\n        deferred_attr.__set__(instance, 'new_value')\n        self.assertEqual(instance.__dict__['mock_field'], 'new_value')\n\n        # Test getting the value after setting\n        retrieved_value = deferred_attr.__get__(instance)\n        self.assertEqual(retrieved_value, 'new_value')\n\n    def test_select_related_descend(self):\n        mock_field = Mock()\n        mock_field.remote_field = True\n        mock_field.null = False\n        mock_field.name = 'related_field'\n        requested = {'related_field': True}\n        load_fields = {'related_field'}\n\n        result = select_related_descend(mock_field, False, requested, load_fields)\n        self.assertTrue(result)\n\n        # Test with restricted and reverse\n        result = select_related_descend(mock_field, True, requested, load_fields, reverse=True)\n        self.assertTrue(result)\n\n        # Test with no requested fields\n        result = select_related_descend(mock_field, False, {}, load_fields)\n        self.assertFalse(result)\n\n        # Test with a field that is not remote\n        mock_field.remote_field = False\n        result = select_related_descend(mock_field, False, requested, load_fields)\n        self.assertFalse(result)\n\n    def test_refs_expression(self):\n        lookup_parts = ['field1', 'field2']\n        annotations = {'field1': True, 'field1__field2': True}\n\n        found, remaining = refs_expression(lookup_parts, annotations)\n        self.assertTrue(found)\n        self.assertEqual(remaining, ['field2'])\n\n        # Test with no matches\n        lookup_parts_no_match = ['field3']\n        found, remaining = refs_expression(lookup_parts_no_match, annotations)\n        self.assertFalse(found)\n        self.assertEqual(remaining, ['field3'])\n\n        # Test with partial matches\n        lookup_parts_partial = ['field1', 'field3']\n        found, remaining = refs_expression(lookup_parts_partial, annotations)\n        self.assertTrue(found)\n        self.assertEqual(remaining, ['field3'])\n\n    def test_check_rel_lookup_compatibility(self):\n        mock_model = Mock()\n        mock_target_opts = Mock()\n        mock_field = Mock()\n        mock_model._meta.concrete_model = mock_model\n        mock_target_opts.concrete_model = mock_target_opts\n\n        result = check_rel_lookup_compatibility(mock_model, mock_target_opts, mock_field)\n        self.assertTrue(result)\n\n        # Test with incompatible models\n        mock_target_opts.concrete_model = Mock()\n        mock_target_opts.concrete_model._meta.model_name = 'different_model'\n        result = check_rel_lookup_compatibility(mock_model, mock_target_opts, mock_field)\n        self.assertFalse(result)\n\n        # Test with None model\n        mock_target_opts.concrete_model = None\n        result = check_rel_lookup_compatibility(mock_model, mock_target_opts, mock_field)\n        self.assertFalse(result)\n\n    def test_filtered_relation_initialization(self):\n        with self.assertRaises(ValueError):\n            FilteredRelation('', condition=Q())\n\n        relation = FilteredRelation('relation_name', condition=Q())\n        self.assertEqual(relation.relation_name, 'relation_name')\n\n        # Test with None condition\n        with self.assertRaises(ValueError):\n            FilteredRelation('relation_name', condition=None)\n\n    def test_filtered_relation_condition_type(self):\n        with self.assertRaises(ValueError):\n            FilteredRelation('relation_name', condition='not_a_q_instance')\n\n        # Test with valid Q instance\n        relation = FilteredRelation('relation_name', condition=Q(field='value'))\n        self.assertEqual(relation.condition, Q(field='value'))\n\n        # Test with empty Q instance\n        empty_relation = FilteredRelation('relation_name', condition=Q())\n        self.assertEqual(empty_relation.condition, Q())\n\n    def test_filtered_relation_equality(self):\n        relation1 = FilteredRelation('relation_name', condition=Q())\n        relation2 = FilteredRelation('relation_name', condition=Q())\n        self.assertEqual(relation1, relation2)\n\n        # Test with different conditions\n        relation3 = FilteredRelation('relation_name', condition=Q(field='value'))\n        self.assertNotEqual(relation1, relation3)\n\n        # Test with different relation names\n        relation4 = FilteredRelation('different_name', condition=Q())\n        self.assertNotEqual(relation1, relation4)\n\n    def test_filtered_relation_clone(self):\n        relation = FilteredRelation('relation_name', condition=Q())\n        clone = relation.clone()\n        self.assertEqual(relation, clone)\n        self.assertIsNot(relation, clone)\n\n        # Test that the clone has the same attributes\n        self.assertEqual(clone.relation_name, relation.relation_name)\n        self.assertEqual(clone.condition, relation.condition)\n\n    def test_filtered_relation_invalid_condition(self):\n        with self.assertRaises(ValueError):\n            FilteredRelation('relation_name', condition='invalid')\n\n        # Test with None condition\n        with self.assertRaises(ValueError):\n            FilteredRelation('relation_name', condition=None)"
}
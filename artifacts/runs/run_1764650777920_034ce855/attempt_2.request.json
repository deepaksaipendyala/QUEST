{
  "repo": "django/django",
  "version": "4.0",
  "code_file": "django/db/models/query_utils.py",
  "test_src": "import unittest\nfrom unittest.mock import Mock, patch\nfrom django.core.exceptions import FieldError\nfrom django.db.models.query_utils import Q, select_related_descend, FilteredRelation, check_rel_lookup_compatibility\n\nclass QueryUtilsTests(unittest.TestCase):\n\n    def test_q_combination_and(self):\n        q1 = Q(foo='bar')\n        q2 = Q(baz='qux')\n        combined = q1 & q2\n        self.assertEqual(combined.connector, Q.AND)\n        self.assertEqual(len(combined.children), 2)\n        self.assertIn(('foo', 'bar'), combined.children)\n        self.assertIn(('baz', 'qux'), combined.children)\n\n    def test_q_combination_or(self):\n        q1 = Q(foo='bar')\n        q2 = Q(baz='qux')\n        combined = q1 | q2\n        self.assertEqual(combined.connector, Q.OR)\n        self.assertEqual(len(combined.children), 2)\n        self.assertIn(('foo', 'bar'), combined.children)\n        self.assertIn(('baz', 'qux'), combined.children)\n\n    def test_q_negation(self):\n        q = Q(foo='bar')\n        negated = ~q\n        self.assertTrue(negated.negated)\n        self.assertEqual(len(negated.children), 1)\n        self.assertIn(('foo', 'bar'), negated.children)\n\n    def test_deconstruct_q(self):\n        q = Q(foo='bar', baz='qux', _connector=Q.OR, _negated=True)\n        path, args, kwargs = q.deconstruct()\n        self.assertIn('django.db.models.query_utils.Q', path)\n        self.assertEqual(args, (('foo', 'bar'), ('baz', 'qux')))\n        self.assertEqual(kwargs, {'_connector': Q.OR, '_negated': True})\n\n    def test_deferred_attribute_get(self):\n        mock_field = Mock()\n        mock_field.attname = 'mock_field'\n        instance = Mock()\n        instance.__dict__ = {}\n        deferred = DeferredAttribute(mock_field)\n\n        with patch.object(instance, 'refresh_from_db') as mock_refresh:\n            value = deferred.__get__(instance)\n            self.assertIsNone(value)\n            mock_refresh.assert_called_once_with(fields=['mock_field'])\n\n    def test_select_related_descend(self):\n        mock_field = Mock()\n        mock_field.remote_field = True\n        mock_field.name = 'related_field'\n        mock_field.null = False\n        requested = {'related_field': True}\n        load_fields = {'related_field'}\n        result = select_related_descend(mock_field, False, requested, load_fields)\n        self.assertTrue(result)\n\n        # Test with no requested fields\n        requested_empty = {}\n        result_empty = select_related_descend(mock_field, False, requested_empty, load_fields)\n        self.assertFalse(result_empty)\n\n        # Test with null field\n        mock_field.null = True\n        requested_null = {'related_field': None}\n        result_null = select_related_descend(mock_field, False, requested_null, load_fields)\n        self.assertFalse(result_null)\n\n    def test_check_rel_lookup_compatibility(self):\n        model = Mock()\n        target_opts = Mock()\n        field = Mock()\n        model._meta.concrete_model = 'ModelA'\n        target_opts.concrete_model = 'ModelA'\n        field.primary_key = False\n\n        self.assertTrue(check_rel_lookup_compatibility(model, target_opts, field))\n\n        # Test with different models\n        target_opts.concrete_model = 'ModelB'\n        self.assertFalse(check_rel_lookup_compatibility(model, target_opts, field))\n\n        # Test with primary key\n        field.primary_key = True\n        self.assertTrue(check_rel_lookup_compatibility(model, target_opts, field))\n\n    def test_filtered_relation_initialization(self):\n        with self.assertRaises(ValueError):\n            FilteredRelation('', condition=Q())\n\n    def test_filtered_relation_condition_type(self):\n        with self.assertRaises(ValueError):\n            FilteredRelation('relation_name', condition='not_a_q_instance')\n\n    def test_filtered_relation_equality(self):\n        fr1 = FilteredRelation('relation_name', condition=Q(foo='bar'))\n        fr2 = FilteredRelation('relation_name', condition=Q(foo='bar'))\n        self.assertEqual(fr1, fr2)\n        self.assertIsNot(fr1, fr2)\n\n        fr3 = FilteredRelation('relation_name', condition=Q(foo='baz'))\n        self.assertNotEqual(fr1, fr3)\n\n    def test_filtered_relation_clone(self):\n        fr = FilteredRelation('relation_name', condition=Q(foo='bar'))\n        clone = fr.clone()\n        self.assertEqual(fr, clone)\n        self.assertIsNot(fr, clone)\n\n    def test_filtered_relation_invalid_condition(self):\n        with self.assertRaises(ValueError):\n            FilteredRelation('relation_name', condition=None)\n\n    def test_filtered_relation_with_empty_condition(self):\n        fr = FilteredRelation('relation_name', condition=Q())\n        self.assertEqual(fr.condition, Q())\n\n    def test_filtered_relation_with_multiple_conditions(self):\n        fr1 = FilteredRelation('relation_name', condition=Q(foo='bar') & Q(baz='qux'))\n        fr2 = FilteredRelation('relation_name', condition=Q(foo='bar') & Q(baz='qux'))\n        self.assertEqual(fr1, fr2)\n\n    def test_filtered_relation_with_different_conditions(self):\n        fr1 = FilteredRelation('relation_name', condition=Q(foo='bar'))\n        fr2 = FilteredRelation('relation_name', condition=Q(baz='qux'))\n        self.assertNotEqual(fr1, fr2)\n\n    def test_q_combination_and_empty(self):\n        q1 = Q()\n        q2 = Q(baz='qux')\n        combined = q1 & q2\n        self.assertEqual(combined, q2)\n\n    def test_q_combination_or_empty(self):\n        q1 = Q()\n        q2 = Q(baz='qux')\n        combined = q1 | q2\n        self.assertEqual(combined, q2)\n\n    def test_q_negation_empty(self):\n        q = Q()\n        negated = ~q\n        self.assertTrue(negated.negated)\n        self.assertEqual(len(negated.children), 0)\n\n    def test_deconstruct_q_empty(self):\n        q = Q()\n        path, args, kwargs = q.deconstruct()\n        self.assertIn('django.db.models.query_utils.Q', path)\n        self.assertEqual(args, ())\n        self.assertEqual(kwargs, {})\n\n    def test_select_related_descend_with_none(self):\n        mock_field = Mock()\n        mock_field.remote_field = True\n        mock_field.name = 'related_field'\n        mock_field.null = True\n        requested = {'related_field': None}\n        load_fields = {'related_field'}\n        result = select_related_descend(mock_field, False, requested, load_fields)\n        self.assertFalse(result)\n\n    def test_check_rel_lookup_compatibility_primary_key(self):\n        model = Mock()\n        target_opts = Mock()\n        field = Mock()\n        model._meta.concrete_model = 'ModelA'\n        target_opts.concrete_model = 'ModelA'\n        field.primary_key = True\n\n        self.assertTrue(check_rel_lookup_compatibility(model, target_opts, field))\n\n    def test_check_rel_lookup_compatibility_different_primary_key(self):\n        model = Mock()\n        target_opts = Mock()\n        field = Mock()\n        model._meta.concrete_model = 'ModelA'\n        target_opts.concrete_model = 'ModelA'\n        field.primary_key = False\n\n        self.assertTrue(check_rel_lookup_compatibility(model, target_opts, field))\n\n        target_opts.concrete_model = 'ModelB'\n        self.assertFalse(check_rel_lookup_compatibility(model, target_opts, field))"
}